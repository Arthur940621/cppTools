# 入门

## `Git` 的基础

要把文档还原到编辑前的状态，最简单的方法就是先备份编辑前的文档。比如，在备份的文档名或目录名上添加编辑的日期。但是，每次编辑文档都要事先复制，这样非常麻烦，也很容易出错。

![001]()

如果像上图那样毫无命名规则的话，就无法区分哪一个文档是最新的了。而且，如果是共享文件的话，应该加上编辑者的名字。还有，那些文档名字没有体现修改内容。

另外，如果两个人同时编辑某个共享文件，先进行编辑的人所做的修改内容会被覆盖。

![002]()

`Git` 版本管理系统就是为了解决这些问题应运而生的。

`Git` 是一个分布式版本管理系统，是为了更好地管理 `Linux` 内核开发而创立的。

`Git` 可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。

而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。

![003]()

数据库是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。

![004]()

首先，`Git` 的数据库分为远程数据库和本地数据库的两种:
- 远程数据库: 配有专用的服务器，为了多人共享而建立的数据库。
- 本地数据库: 为了方便用户个人使用，在自己的机器上配置的数据库。

平时用手头上的机器在本地数据库上操作就可以了。如果想要公开在本地数据库中修改的内容，把内容上传到远程数据库就可以了。另外，通过远程数据库还可以取得其他人修改的内容。

![005]()

创建本地数据库的方法有两种: 一种是创建全新的数据库，另一种是复制远程数据库。

![006]()

若要把文件或目录的添加和变更保存到数据库，就需要进行提交。

执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也被称为 `revision`）。

如下图，提交是以时间顺序排列状态被保存到数据库中的。凭借该提交和最新的文件状态，就可以知道过去的修改记录以及内容。

![007]()

系统会根据修改的内容计算出没有重复的 `40` 位英文及数字来给提交命名。指定这个命名，就可以在数据库中找到对应的提交。

不同类别的修改（如: `Bug` 修复和功能添加）要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。

执行提交时，系统会要求输入提交信息。请务必输入提交信息，因为在空白的状态下执行提交会失败的。

查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。

以下是 `Git` 的标准注解:

```
第1行: 提交修改内容的摘要
第2行: 空行
第3行以后: 修改的理由
```

在 `Git` 管理下，实际操作的目录被称为工作树。

在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。

![008]()

`Git` 在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。

所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。

## 共享数据库

为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。

为此，需要在 `Git` 执行推送（`Push`）操作。执行 `Push` 之后，本地的修改记录会被上传到远程数据库。所以远程数据库的修改记录就会和本地数据库的修改记录保持同步。

![009]()

进行克隆（`Clone`）操作就可以复制远程数据库。

执行克隆后，远程数据库的全部内容都会被下载。之后在另一台机器的本地数据库上进行操作。

克隆后的本地数据库的变更履历也会被复制，所以可以像原始的数据库一样进行查看记录或其他操作。

若是共享的远程数据库由多人同时作业，那么作业完毕后所有人都要把修改推送到远程数据库。然后，自己的本地数据库也需要更新其他人推送的变更内容。

进行拉取（`Pull`）操作就可以把远程数据库的内容更新到本地数据库。

进行拉取（`Pull`）操作，就是从远程数据库下载最近的变更日志，并覆盖自己本地数据库的相关内容。

## 整合修改记录

![010]()

在执行 `pull` 之后，进行下一次 `push` 之前，如果其他人进行了推送内容到远程数据库的话，那么你的 `push` 将被拒绝。

![011]()

这种情况下，在读取别人 `push` 的变更并进行合并操作之前，你的 `push` 都将被拒绝。这是因为，如果不进行合并就试图覆盖已有的变更记录的话，其他人 `push` 的变更（图中的提交 `C`）就会丢失。

合并的时候，`Git` 会自动合并已有的变更点，不过，也存在不能自动合并的情况。

如果远程数据库和本地数据库的同一个地方都发生了修改的情况下，因为无法自动判断要选用哪一个修改，所以就会发生冲突。

`Git` 会在发生冲突的地方修改文件的内容，如下图。所以我们需要手动修正冲突。

![012]()

==分割线上方是本地数据库的内容,下方是远程数据库的编辑内容。

如下图所示，修正所有冲突的地方之后，执行提交。

![013]()

# 高级

## 分支

在开发软件时，可能有多人同时为同一个软件开发功能或修复 `BUG`，可能存在多个 `Release` 版本，并且需要对各个版本进行维护。

`Git` 的分支功能可以支持同时进行多个功能的开发和版本管理。

分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。

![014]()

分叉的分支可以合并。

下面是使用分支进行作业的图示。

为了不受其他开发人员的影响，可以在主分支上建立自己专用的分支。完成工作后，将自己分支上的修改合并到主分支。因为每一次提交的历史记录都会被保存，所以当发生问题时，定位和修改造成问题的提交就容易多了。

![015]()

在数据库进行最初的提交后，`Git` 会创建一个名为 `master` 的分支。因此之后的提交，在切换分支之前都会添加到 `master` 分支里。

![016]()

`Merge` 分支

`Merge` 分支是为了可以随时发布 `release` 而创建的分支，它还能作为 `Topic` 分支的源分支使用。

通常会将 `master` 分支当作 `Merge` 分支使用。

`Topic` 分支

`Topic` 分支是为了开发新功能或修复 `Bug` 等任务而建立的分支。若要同时进行多个的任务，创建多个的 `Topic` 分支。

`Topic` 分支是从稳定的 `Merge` 分支创建的。完成作业后，要把 `Topic` 分支合并回 `Merge` 分支。

![017]()

若要切换作业的分支，就要进行 `checkout` 操作。进行 `checkout` 时，`git` 会从工作树还原向目标分支提交的修改内容。`checkout` 之后的提交记录将被追加到目标分支。

![018]()

`HEAD` 指向的是现在使用中的分支的最后一次更新。通常默认指向 `master` 分支的最后一次更新。通过移动 `HEAD`，就可以变更使用的分支。

提交时使用 `~` 和 `^` 就可以指定某个提交的相对位置。最常用的就是相对于 `HEAD` 的位置。`HEAD` 后面加上 `~` 可以指定 `HEAD` 之前的提交记录。合并分支会有多个根节点，可以用 `^` 来指定使用哪个为根节点。

用tilde和caret指定提交的相对位置

stash
还未提交的修改内容以及新添加的文件，留在索引区域或工作树的情况下切换到其他的分支时，修改内容会从原来的分支移动到目标分支。

但是如果在checkout的目标分支中相同的文件也有修改，checkout会失败的。这时要么先提交修改内容，要么用stash暂时保存修改内容后再checkout。

stash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。

stash

## 远端数据库

## 标签

## 改写提交

